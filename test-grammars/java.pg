grammar 'Java';

Java = CompilationUnit ;

OptDocComment = (DocComment)? ;

TypeDeclaration =
 OptDocComment ( ClassDeclaration | InterfaceDeclaration | EnumDeclaration | AnnotationDeclaration )  ;

ImportList = (ImportStatement)*;
CompilationUnit  =
 (Package)?
 ImportList
 (TypeDeclaration)?  ;

Package  =
 'package' CompoundName  ';'  ;

ImportStatement  =
 'import'  (  ( CompoundName  '.'  '*' )
 | CompoundName  )  ';'  ;

DocComment = doccomment;

# Annotations support
Annotation = '@' CompoundName ('(' AnnotationArguments? ')')? ;

AnnotationArguments = AnnotationElement (',' AnnotationElement)* ;

AnnotationElement = (id '=')? Expression ;

AnnotationList = Annotation* ;

# NOTE: ModifierList creates shift/reduce conflicts (~14) because the parser must decide
# when to stop adding modifiers/annotations and start parsing the Type. These conflicts
# resolve correctly with lookahead (inherent to the grammar design).
ModifierList = (Modifier | Annotation)* ;

ExtendsList = ('extends' CompoundName (',' CompoundName)*)? ;
ImplementsList = 'implements' CompoundName + ',';
FieldDeclarationList = FieldDeclaration *;

ClassDeclaration  =
 ModifierList 'class' id TypeParameters
 ExtendsList?
 ImplementsList?
 '{'  FieldDeclarationList  '}'  ;

InterfaceDeclaration  =
 ModifierList 'interface' id TypeParameters
 ExtendsList
 '{'  FieldDeclarationList  '}'  ;

# Annotation declaration (@interface)
AnnotationDeclaration =
 ModifierList '@' 'interface' id
 '{' AnnotationTypeElementList '}' ;

AnnotationTypeElementList = AnnotationTypeElement* ;

AnnotationTypeElement =
 ModifierList Type id '(' ')' ('default' Expression)? ';'
 | FieldDeclaration ;

# Enum declaration
EnumConstant = AnnotationList id ('(' Arglist ')')? ('{' FieldDeclarationList '}')? ;

EnumConstantList = EnumConstant (',' EnumConstant)* (',')? ;

EnumDeclaration =
 ModifierList 'enum' id
 ImplementsList?
 '{' EnumConstantList (';' FieldDeclarationList)? '}' ;

FieldDeclaration  =
 (ModifierList ((  DocComment?  ( MethodDeclaration
 | ConstructorDeclaration
 | VariableDeclaration
 | ClassDeclaration ))
 | StaticInitializer))
 |  ';'  ;

SquareBracketsList = ('[' OptExpression ']')* ;

MethodDeclaration  =
 TypeParameters Type id
 '('  ParameterList  ')'  SquareBracketsList
 ( StatementBlock  |  ';'  )  ;

ConstructorDeclaration  =
 id  '('  ParameterList  ')'
StatementBlock  ;

StatementBlock  =  '{'  StatementList  '}'  ;

VariableDeclaratorList = VariableDeclarator (',' VariableDeclarator)* ;

VariableDeclaration  =
 Type VariableDeclaratorList
   ';'  ;

OptVariableInitializer = ('=' VariableInitializer)? ;

VariableDeclarator  =
 id  SquareBracketsList  OptVariableInitializer  ;

VariableInitializerList = VariableInitializer * ',' ( ',' )? ;

VariableInitializer  =
Expression
 |  '{'  VariableInitializerList  '}'  ;

StaticInitializer  =
 StatementBlock  ;

ParameterList  =
Parameter * ','  ;

Parameter  =
Type id SquareBracketsList ;

StatementList = Statement *;

OptExpression = Expression? ;

OptId = id?;

Statement =
 StatementWithoutIf
 |  IfStatement
  ;

StatementWithoutIf =
VariableDeclaration
 |  'return'  OptExpression  ';'
 |  Expression  ';'
 |  StatementBlock
 |  DoStatement
 |  WhileStatement
 |  ForStatement
 |  TryStatement
 |  SwitchStatement
 |  'synchronized'  '(' Expression  ')' Statement
 |  'throw' Expression ';'
 |  id  ':' Statement
 |  'break'  OptId  ';'
 |  'continue'  OptId  ';'
 |  ';' ;

OptElsePart = ('else' Statement)? ;

# NOTE: If-else statements create shift/reduce conflicts due to the dangling-else problem.
# The current design with StatementWithoutIf resolves this correctly by binding else to
# the nearest if. These conflicts (~13) are acceptable and standard in Java parsers.
IfStatement =
 'if'  '(' Expression  ')' StatementWithoutIf
   OptElsePart ;

DoStatement =
 'do' Statement  'while'  '(' Expression  ')'  ';'  ;

WhileStatement =
 'while'  '(' Expression  ')' Statement  ;

ForStatement =
 'for'  '('  ( VariableDeclaration  |  ( Expression  ';'  )  |  ';'  )
 OptExpression  ';'
 OptExpression
 ')' Statement  ;

CatchList = (  'catch'  '(' Parameter  ')' Statement)* ;

OptFinally = ('finally' Statement)?;

TryStatement =
 'try' Statement
  CatchList
  OptFinally  ;

SwitchCaseList = ((  'case' Expression  ':'  )
 |  (  'default'  ':'  )
 | Statement )*;

SwitchStatement =
 'switch'  '(' Expression  ')'  '{'
 SwitchCaseList
 '}'  ;

# Expression Hierarchy
# Restructured to eliminate reduce/reduce conflicts by ensuring a single parse path
# through the operator precedence chain. Each expression level flows into the next
# without overlapping alternatives.
Expression = AssignmentExpression ;

AssignmentExpression =
 ConditionalExpression
 | Assignment ;

# COMMENTED OUT - CAUSES LEFT RECURSION:
 # | Expression (/*NumericExpressionEnd
 # | TestingExpressionEnd
 # | LogicalExpressionEnd
 # | BitExpressionEnd
 # | */'(' Arglist ')'
 # | '[' Expression  ']'
 # | '.' Expression
 # | ',' Expression
 # | 'instanceof'  CompoundName )

FieldAccess = Primary '.' id | 'super' '.' id ;

LeftHandSide = CompoundName
 | FieldAccess
 | ArrayAccess ;

AssignmentOp =
 '+='
 | '-='
 | '*='
 | '|='
 | '&='
 | '^='
 | '%=' ;

Assignment = LeftHandSide AssignmentOp Expression;

ConditionalExpression = ConditionalOrExpression | ConditionalOrExpression '?' Expression ':' ConditionalExpression ;

ConditionalOrExpression = ConditionalAndExpression | ConditionalOrExpression '||' ConditionalAndExpression ;

ConditionalAndExpression = InclusiveOrEpression | ConditionalAndExpression '&&' InclusiveOrEpression ;

InclusiveOrEpression = ExclusiveOrExpression | InclusiveOrEpression '|' ExclusiveOrExpression;

ExclusiveOrExpression = AndExpression | ExclusiveOrExpression '^' AndExpression ;

AndExpression = EqualityExpression | AndExpression '&' EqualityExpression ;

EqualityOp = '==' | '!=' ;

EqualityExpression = RelationalExpression | EqualityExpression EqualityOp RelationalExpression ;

RelationalOp = '<' | '>' | '<=' | '>=' ;

RelationalExpression = ShiftExpression | RelationalExpression RelationalOp ShiftExpression | RelationalExpression 'instanceof' Type ;

ShiftOp = '>>' | '<<' | '>>>' ;

ShiftExpression = AdditiveExpression | ShiftExpression ShiftOp AdditiveExpression ;

AdditiveOp = '+' | '-' ;

AdditiveExpression = MultiplicativeExpression | AdditiveExpression AdditiveOp MultiplicativeExpression ;

MultiplicativeOp = '*' | '/' | '%' ;

MultiplicativeExpression = UnaryExpression | MultiplicativeExpression MultiplicativeOp UnaryExpression ;

CastExpression = '(' Type ')' UnaryExpression ;

PrefixOp = '++' | '--' | '+' | '-' | '~' | '!' ;

PostfixOp = '++' | '--' ;

UnaryExpression =
 PrefixOp UnaryExpression
 | UnaryExpressionNotPlusMinus ;

UnaryExpressionNotPlusMinus =
 PostfixExpression
 | '~' UnaryExpression
 | '!' UnaryExpression
 | CastExpression ;

PostfixExpression =
 Primary
 | PostfixExpression PostfixOp ;

Primary =
 Literal
 | 'this'
 | '(' Expression ')'
 | CreationExpression
 | FieldAccess
 | MethodInvocation
 | ArrayAccess
 | CompoundName ;

CreationExpression = 'new' Type ( '(' Arglist ')' | SquareBracketsList );

ArrayAccess = CompoundName '[' Expression ']' | Primary '[' Expression ']' ;

Literal = integerLiteral | floatLiteral | 'true' | 'false' | char | string | 'null' ;

MethodInvocation = CompoundName '(' Arglist ')' | Primary '.' id  '(' Arglist ')' | 'super' '.' id '(' Arglist ')' ;

Arglist = Expression * ',' ;

# Generics support
# NOTE: The '<' and '>' symbols create shift/reduce conflicts (~60) because they are used for both:
#   - Type arguments: List<String>
#   - Comparison operators: x < y
# These conflicts resolve correctly with default shift behavior (standard for Java parsers).
TypeArguments = ('<' TypeArgument (',' TypeArgument)* '>')? ;

TypeArgument =
 Type
 | WildcardType ;

WildcardType =
 '?'
 | '?' 'extends' Type
 | '?' 'super' Type ;

TypeParameters = ('<' TypeParameter (',' TypeParameter)* '>')? ;

TypeParameter = id ('extends' Type ('&' Type)*)? ;

Type  =
TypeSpecifier  SquareBracketsList  ;

TypeSpecifier =
 'boolean'
 |  'byte'
 |  'char'
 |  'short'
 |  'int'
 |  'float'
 |  'long'
 |  'double'
 |  'void'
 | CompoundName TypeArguments ;

Modifier =
 'public'
 |  'private'
 |  'protected'
 |  'static'
 |  'final'
 |  'native'
 |  'synchronized'
 |  'abstract'
 |  'threadsafe'
 |  'transient'  ;

CompoundName =
id ('.' id)*;

integerLiteral =
 (  (  [1-9]  [0-9]*  )
 |  ( '0' [0-7]* )
 |  (  '0'  'x'  [0-9a-fA-F]+   )  )
 [l]?  ;

floatLiteral  =
 [0-9]+ '.' ([0-9]+)? exponentPart? floatTypeSuffix?
 |  '.' [0-9]+ exponentPart? floatTypeSuffix?
 |  [0-9]+ floatTypeSuffix ;

exponentPart  =
 'e'  (  '+'  |  '-'  )? [0-9]+  ;

floatTypeSuffix  =
 'f'  |  'd'  ;

char  = '\'' . '\'' ;

string  = [\"] [\\x20-\\x21\\x23-\\x7E]* [\"] ;

id = [a-zA-Z$_][a-zA-Z$_0-9]* ;
doccomment = '/**' (([^/] | [\n]) ([^\*] | [\*] [^/] | [\n])*)? '*/';

# Whitespace and comments (ignored)
Ignore: ws = [ \t\n\r]+ ;
Ignore: comment = '//' [^\n]* '\n' ;
Ignore: blockComment = '/*' (([^\*] | [\n]) ([^\*] | [\*] [^/] | [\n])*)? '*/' ;
