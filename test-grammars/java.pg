grammar 'Java';

Java = CompilationUnit ;

OptDocComment = (DocComment)? ; 

TypeDeclaration = 
 OptDocComment  ( ClassDeclaration | InterfaceDeclaration )  ';'  ;

ImportList = (ImportStatement)*;
CompilationUnit  = 
 (Package)?
 ImportList
 (TypeDeclaration)?  ;

Package  = 
 'package' PackageName  ';'  ;

ImportStatement  = 
 'import'  (  ( PackageName  '.'  '*'  ';'  ) 
 |  ( ClassName  | InterfaceName )  )  ';'  ; 

DocComment = doccomment;

ModifierList = Modifier *;

ExtendsList = 'extends' ClassName * 'extends' ;
ImplementsList = 'implements' InterfaceName + ',';
FieldDeclarationList = FieldDeclaration *;

ClassDeclaration  = 
 ModifierList  'class' id 
 ExtendsList?
 ImplementsList? 
 '{'  FieldDeclarationList  '}'  ; 

InterfaceDeclaration  = 
 ModifierList  'interface' id 
 ExtendsList
 '{'  FieldDeclarationList  '}'  ; 

FieldDeclaration  = 
 (ModifierList ((  DocComment?  ( MethodDeclaration 
 | ConstructorDeclaration 
 | VariableDeclaration )  ) 
 | StaticInitializer)) 
 |  ';'  ; 

SquareBracketsList = ('['  ']')* ;

MethodDeclaration  = 
 Type id 
 '('  ParameterList  ')'  SquareBracketsList 
 ( StatementBlock  |  ';'  )  ;

ConstructorDeclaration  = 
 id  '('  ParameterList  ')' 
StatementBlock  ; 

StatementBlock  =  '{'  StatementList  '}'  ; 

VariableDeclaratorList = VariableDeclarator + ',' ;

VariableDeclaration  = 
 Type VariableDeclaratorList 
   ';'  ; 

OptVariableInitializer = ('=' VariableInitializer)? ;

VariableDeclarator  = 
 id  SquareBracketsList  OptVariableInitializer  ; 

VariableInitializerList = VariableInitializer * ',' ( ',' )? ;

VariableInitializer  = 
Expression 
 |  '{'  VariableInitializerList  '}'  ; 

StaticInitializer  = 
 StatementBlock  ; 

ParameterList  = 
Parameter * ','  ; 

Parameter  = 
Type id SquareBracketsList ; 

StatementList = Statement *;

OptExpression = Expression? ;

OptId = id?;

Statement  = 
VariableDeclaration 
 |  ( Expression  ';'  ) 
 |  ( StatementBlock ) 
 |  ( IfStatement ) 
 |  ( DoStatement ) 
 |  ( WhileStatement ) 
 |  ( ForStatement ) 
 |  ( TryStatement ) 
 |  ( SwitchStatement ) 
 |  (  'synchronized'  '(' Expression  ')' Statement  ) 
 |  (  'return'  OptExpression  ';'  ) 
 |  (  'throw' Expression ';'  ) 
 |  ( id  ':' Statement ) 
 |  (  'break'  OptId  ';'  ) 
 |  (  'continue'  OptId  ';'  ) 
 |  (  ';'  )  ;

OptElsePart = ('else' Statement)? ;

IfStatement = 
 'if'  '(' Expression  ')' Statement 
   OptElsePart ; 

DoStatement = 
 'do' Statement  'while'  '(' Expression  ')'  ';'  ; 

WhileStatement = 
 'while'  '(' Expression  ')' Statement  ; 

ForStatement = 
 'for'  '('  ( VariableDeclaration  |  ( Expression  ';'  )  |  ';'  ) 
 OptExpression  ';' 
 OptExpression  ';' 
 ')' Statement  ; 

CatchList = (  'catch'  '(' Parameter  ')' Statement)* ;

OptFinally = ('finally' Statement)?;

TryStatement = 
 'try' Statement 
  CatchList
  OptFinally  ; 

SwitchCaseList = ((  'case' Expression  ':'  ) 
 |  (  'default'  ':'  ) 
 | Statement )*;

SwitchStatement = 
 'switch'  '(' Expression  ')'  '{' 
 SwitchCaseList 
 '}'  ;

Expression  = 
NumericExpression 
 | TestingExpression 
 | LogicalExpression 
 | StringExpression 
 | BitExpression 
 | CastingExpression 
 | CreatingExpression 
 | LiteralExpression 
 |  'null' 
 |  'super' 
 |  'this' 
 | id 
 |  (  '(' Expression  ')'  ) 
 |  ( Expression 
 (  (  '(' Arglist ')'  ) 
 |  (  '[' Expression  ']'  ) 
 |  (  '.' Expression  ) 
 |  (  ',' Expression  ) 
 |  (  'instanceof'  ( ClassName | InterfaceName )  ) 
 )  )  ;

NumericExpression  = 
 (  (  '-' 
 |  '++' 
 |  '--'  ) 
Expression ) 
 |  ( Expression 
 (  '++' 
 |  '--'  )  ) 
 |  ( Expression 
 (  '+' 
 |  '+=' 
 |  '-' 
 |  '-=' 
 |  '*' 
 |  '*=' 
 |  '|' 
 |  '|=' 
 |  '%' 
 |  '%='  ) 
Expression  )  ; 

TestingExpression  = 
 ( Expression 
 (  '>' 
 |  '<' 
 |  '>=' 
 |  '<=' 
 |  '==' 
 |  '!='  ) 
Expression  )  ; 

LogicalExpression  = 
 (  '!' Expression ) 
 |  ( Expression 
 (  'ampersand' 
 |  'ampersand=' 
 |  '|' 
 |  '|=' 
 |  '^' 
 |  '^=' 
 |  (  'ampersand'  'ampersand'  ) 
 |  '||=' 
 |  '%' 
 |  '%='  ) 
Expression  ) 
 |  ( Expression  '?' Expression  ':' Expression ) 
 |  'true' 
 |  'false'  ; 

StringExpression  =  ( Expression 
 (  '+' 
 |  '+='  ) 
Expression  )  ;

BitExpression  = 
 (  '~' Expression ) 
 |  ( Expression 
 (  '>>=' 
 |  '<<' 
 |  '>>' 
 |  '>>>'  ) 
Expression  )  ; 

CastingExpression  = 
 '(' Type  ')' Expression  ; 

OptBracketExpression = (  '[' Expression  ']' )? ;

CreatingExpression  = 
 'new'  (  ( ClassName  '('  Arglist  ')'  ) 
 |  ( TypeSpecifier  OptBracketExpression  SquareBracketsList  ) 
 |  (  '(' Expression  ')'  )  )  ; 

LiteralExpression  = 
integerLiteral 
 | floatLiteral 
 | string 
 | char  ; 

Arglist  = 
  Expression * ','  ; 

Type  = 
TypeSpecifier  SquareBracketsList  ;

TypeSpecifier = 
 'boolean' 
 |  'byte' 
 |  'char' 
 |  'short' 
 |  'int' 
 |  'float' 
 |  'long' 
 |  'double' 
 | ClassName 
 | InterfaceName  ; 

Modifier = 
 'public' 
 |  'private' 
 |  'protected' 
 |  'static' 
 |  'final' 
 |  'native' 
 |  'synchronized' 
 |  'abstract' 
 |  'threadsafe' 
 |  'transient'  ; 
 
PackageName = 
id 
 |  ( PackageName  '.' id )  ;

ClassName  = 
id 
 |  ( PackageName  '.' id )  ; 

InterfaceName = 
id 
 |  ( PackageName  '.' id )  ; 

integerLiteral = 
 (  (  [1..9]  [0..9]*  ) 
 |  [0..7]* 
 |  (  '0'  'x'  [0..9a..f]  [0..9a..f]*   )  ) 
 [l]?  ; 

floatLiteral  = 
 ( decimalDigits  '.'  decimalDigits? exponentPart?  floatTypeSuffix?  ) 
 |  (  '.' decimalDigits  exponentPart?  floatTypeSuffix?  ) 
 |  ( decimalDigits  exponentPart?  floatTypeSuffix?  )  ; 

decimalDigits  = 
 [0..9]  [0..9]*  ; 

exponentPart  = 
 'e'  (  '+'  |  '-'  )? decimalDigits  ; 

floatTypeSuffix  = 
 'f'  |  'd'  ; 

char  =
  [a-zA-Z]  ; # should be checked to support unicode characters 

string  =  
 '"'  [a-zA-Z]*  '"'  ;

id = [a-zA-Z$_][A-Za-z$0-9_]* ;
doccomment = '/**' ([^\r]|[^\n]|.)* '*/';

