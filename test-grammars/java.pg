grammar 'Java';

Java = CompilationUnit ;

OptDocComment = (DocComment)? ;

TypeDeclaration =
 OptDocComment ( ClassDeclaration | InterfaceDeclaration | EnumDeclaration | AnnotationDeclaration )  ;

ImportList = (ImportStatement)*;
CompilationUnit  =
 (Package)?
 ImportList
 (TypeDeclaration)?  ;

Package  =
 'package' CompoundName  ';'  ;

ImportStatement  =
 'import'  (  ( CompoundName  '.'  '*' )
 | CompoundName  )  ';'  ;

DocComment = doccomment;

# Annotations support
Annotation = '@' CompoundName ('(' AnnotationArguments? ')')? ;

AnnotationArguments = AnnotationElement (',' AnnotationElement)* ;

AnnotationElement = (id '=')? Expression ;

AnnotationList = Annotation* ;

# NOTE: ModifierList creates shift/reduce conflicts (~14) because the parser must decide
# when to stop adding modifiers/annotations and start parsing the Type. These conflicts
# resolve correctly with lookahead (inherent to the grammar design).
ModifierList = (Modifier | Annotation)* ;

ExtendsList = ('extends' CompoundName (',' CompoundName)*)? ;
ImplementsList = 'implements' CompoundName + ',';
FieldDeclarationList = FieldDeclaration *;

ClassDeclaration  =
 ModifierList 'class' id TypeParameters
 ExtendsList?
 ImplementsList?
 '{'  FieldDeclarationList  '}'  ;

InterfaceDeclaration  =
 ModifierList 'interface' id TypeParameters
 ExtendsList
 '{'  FieldDeclarationList  '}'  ;

# Annotation declaration (@interface)
AnnotationDeclaration =
 ModifierList '@' 'interface' id
 '{' AnnotationTypeElementList '}' ;

AnnotationTypeElementList = AnnotationTypeElement* ;

AnnotationTypeElement =
 ModifierList Type id '(' ')' ('default' Expression)? ';'
 | FieldDeclaration ;

# Enum declaration
EnumConstant = AnnotationList id ('(' Arglist ')')? ('{' FieldDeclarationList '}')? ;

EnumConstantList = EnumConstant (',' EnumConstant)* (',')? ;

EnumDeclaration =
 ModifierList 'enum' id
 ImplementsList?
 '{' EnumConstantList (';' FieldDeclarationList)? '}' ;

# NOTE: MemberDeclaration unifies MethodDeclaration, VariableDeclaration, and ConstructorDeclaration
# to eliminate ambiguity. All three can start with an identifier:
# - Constructor: id '(' ...
# - Method: Type id '(' ...  (where Type can be CompoundName, which is also id)
# - Field: Type id ';' or '=' ...
# By structuring alternatives carefully, we can distinguish them.
FieldDeclaration  =
 (ModifierList ((  DocComment?  ( MemberDeclaration
 | ClassDeclaration ))
 | StaticInitializer))
 |  ';'  ;

SquareBracketsList = ('[' OptExpression ']')* ;

# MemberDeclaration unifies constructors, methods, and fields
# Strategy: Disambiguate early by checking what comes first
# - Primitive type keyword → definitely method/field
# - TypeParameters → definitely method (generic)
# - id → could be constructor or reference type method/field
MemberDeclaration =
 PrimitiveTypeKeyword SquareBracketsList id MemberRest         # Primitive type method/field
 | TypeParameters id MoreTypeSpecifier id MemberRest           # Generic method with any type
 | id MemberAfterFirstId ;                                     # Constructor or reference type

# Primitive type keywords (from TypeSpecifier)
PrimitiveTypeKeyword =
 'boolean' | 'byte' | 'char' | 'short' | 'int' | 'float' | 'long' | 'double' | 'void' ;

# After first id (without TypeParameters or primitive type), branch on next token:
MemberAfterFirstId =
 '(' ParameterList? ')' StatementBlock                          # Constructor: id '(' ...
 | MoreTypeSpecifier id MemberRest ;                            # Reference type: id ... id MemberRest

# MoreTypeSpecifier handles the rest of a type after the first id
# Could be: empty (simple type), '.' id (qualified), '<' ... '>' (generics), '[' ']' (array)
MoreTypeSpecifier =
 '.' id MoreTypeSpecifier                                       # Qualified name
 | TypeArguments SquareBracketsList ;                            # Generics + array brackets

# MemberRest branches on what follows "Type id":
# - '(' indicates a method declaration
# - '[' or '=' or ',' or ';' indicates a variable declaration
MemberRest =
 '(' ParameterList? ')' SquareBracketsList ( StatementBlock | ';' )
 | SquareBracketsList OptVariableInitializer MoreVariableDeclarators ';' ;

MoreVariableDeclarators = (',' VariableDeclarator)* ;

# Legacy: MethodDeclaration is now unified with VariableDeclaration in MemberDeclaration above
# MethodDeclaration  =
#  TypeParameters Type id
#  '('  ParameterList  ')'  SquareBracketsList
#  ( StatementBlock  |  ';'  )  ;

# Legacy: ConstructorDeclaration is now unified in MemberDeclaration above
# ConstructorDeclaration  =
#  id  '('  ParameterList  ')'
# StatementBlock  ;

StatementBlock  =  '{'  StatementList  '}'  ;

VariableDeclaratorList = VariableDeclarator (',' VariableDeclarator)* ;

# VariableDeclaration is used for:
# 1. Local variable declarations inside method bodies (via StatementWithoutIf)
# 2. For loops (via ForStatement)
# Note: Field-level variable declarations use MemberDeclaration above
VariableDeclaration  =
 Type VariableDeclaratorList
   ';'  ;

OptVariableInitializer = ('=' VariableInitializer)? ;

VariableDeclarator  =
 id  SquareBracketsList  OptVariableInitializer  ;

VariableInitializerList = (VariableInitializer (',' VariableInitializer)* (',')?)? ;

VariableInitializer  =
Expression
 |  '{'  VariableInitializerList  '}'  ;

StaticInitializer  =
 StatementBlock  ;

ParameterList  =
Parameter (',' Parameter)* ;

Parameter  =
Type id SquareBracketsList ;

StatementList = Statement *;

OptExpression = Expression? ;

OptId = id?;

Statement =
 StatementWithoutIf
 |  IfStatement
  ;

StatementWithoutIf =
VariableDeclaration
 |  'return'  OptExpression  ';'
 |  Expression  ';'
 |  StatementBlock
 |  DoStatement
 |  WhileStatement
 |  ForStatement
 |  TryStatement
 |  SwitchStatement
 |  'synchronized'  '(' Expression  ')' Statement
 |  'throw' Expression ';'
 |  id  ':' Statement
 |  'break'  OptId  ';'
 |  'continue'  OptId  ';'
 |  ';' ;

OptElsePart = ('else' Statement)? ;

# NOTE: If-else statements create shift/reduce conflicts due to the dangling-else problem.
# The current design with StatementWithoutIf resolves this correctly by binding else to
# the nearest if. These conflicts (~13) are acceptable and standard in Java parsers.
IfStatement =
 'if'  '(' Expression  ')' StatementWithoutIf
   OptElsePart ;

DoStatement =
 'do' Statement  'while'  '(' Expression  ')'  ';'  ;

WhileStatement =
 'while'  '(' Expression  ')' Statement  ;

ForStatement =
 'for'  '('  ( VariableDeclaration  |  ( Expression  ';'  )  |  ';'  )
 OptExpression  ';'
 OptExpression
 ')' Statement  ;

CatchList = (  'catch'  '(' Parameter  ')' Statement)* ;

OptFinally = ('finally' Statement)?;

TryStatement =
 'try' Statement
  CatchList
  OptFinally  ;

SwitchCaseList = ((  'case' Expression  ':'  )
 |  (  'default'  ':'  )
 | Statement )*;

SwitchStatement =
 'switch'  '(' Expression  ')'  '{'
 SwitchCaseList
 '}'  ;

# Expression Hierarchy
# Restructured to eliminate reduce/reduce conflicts by ensuring a single parse path
# through the operator precedence chain. Each expression level flows into the next
# without overlapping alternatives.
#
# UPDATED: All expression rules now use shared "Expression" type for QQ support
Expression : Expression = AssignmentExpression ;

Expression : AssignmentExpression =
 ConditionalExpression (AssignmentOp AssignmentExpression)? ;

# COMMENTED OUT - CAUSES LEFT RECURSION:
 # | Expression (/*NumericExpressionEnd
 # | TestingExpressionEnd
 # | LogicalExpressionEnd
 # | BitExpressionEnd
 # | */'(' Arglist ')'
 # | '[' Expression  ']'
 # | '.' Expression
 # | ',' Expression
 # | 'instanceof'  CompoundName )

AssignmentOp =
 '='
 | '+='
 | '-='
 | '*='
 | '/='
 | '|='
 | '&='
 | '^='
 | '%='
 | '<<='
 | '>>='
 | '>>>=' ;

Expression : ConditionalExpression = ConditionalOrExpression | ConditionalOrExpression '?' Expression ':' ConditionalExpression ;

Expression : ConditionalOrExpression = ConditionalAndExpression | ConditionalOrExpression '||' ConditionalAndExpression ;

Expression : ConditionalAndExpression = InclusiveOrEpression | ConditionalAndExpression '&&' InclusiveOrEpression ;

Expression : InclusiveOrEpression = ExclusiveOrExpression | InclusiveOrEpression '|' ExclusiveOrExpression;

Expression : ExclusiveOrExpression = AndExpression | ExclusiveOrExpression '^' AndExpression ;

Expression : AndExpression = EqualityExpression | AndExpression '&' EqualityExpression ;

EqualityOp = '==' | '!=' ;

Expression : EqualityExpression = RelationalExpression | EqualityExpression EqualityOp RelationalExpression ;

RelationalOp = '<' | '>' | '<=' | '>=' ;

Expression : RelationalExpression = ShiftExpression | RelationalExpression RelationalOp ShiftExpression | RelationalExpression 'instanceof' Type ;

ShiftOp = '>>' | '<<' | '>>>' ;

Expression : ShiftExpression = AdditiveExpression | ShiftExpression ShiftOp AdditiveExpression ;

AdditiveOp = '+' | '-' ;

Expression : AdditiveExpression = MultiplicativeExpression | AdditiveExpression AdditiveOp MultiplicativeExpression ;

MultiplicativeOp = '*' | '/' | '%' ;

Expression : MultiplicativeExpression = UnaryExpression | MultiplicativeExpression MultiplicativeOp UnaryExpression ;

Expression : CastExpression = '(' Type ')' UnaryExpression ;

PrefixOp = '++' | '--' | '+' | '-' | '~' | '!' ;

PostfixOp = '++' | '--' ;

Expression : UnaryExpression =
 PrefixOp UnaryExpression
 | UnaryExpressionNotPlusMinus ;

Expression : UnaryExpressionNotPlusMinus =
 PostfixExpression
 | '~' UnaryExpression
 | '!' UnaryExpression
 | CastExpression ;

Expression : PostfixExpression =
 PrimaryNoPostfix
 | PostfixExpression PostfixOp
 | PostfixExpression '.' id
 | PostfixExpression '.' id '(' Arglist ')'
 | PostfixExpression '[' Expression ']' ;

Expression : PrimaryNoPostfix =
 Literal
 | 'this'
 | '(' Expression ')'
 | CreationExpression
 | CompoundName ('(' Arglist ')')?
 | 'super' '.' id ('(' Arglist ')')? ;

CreationExpression = 'new' Type ( '(' Arglist ')' | SquareBracketsList );

Literal = integerLiteral | floatLiteral | 'true' | 'false' | char | string | 'null' ;

Arglist = (Expression (',' Expression)*)? ;

# Generics support
# NOTE: The '<' and '>' symbols create shift/reduce conflicts (~60) because they are used for both:
#   - Type arguments: List<String>
#   - Comparison operators: x < y
# These conflicts resolve correctly with default shift behavior (standard for Java parsers).
TypeArguments = ('<' TypeArgument (',' TypeArgument)* '>')? ;

TypeArgument =
 Type
 | WildcardType ;

WildcardType =
 '?'
 | '?' 'extends' Type
 | '?' 'super' Type ;

TypeParameters = ('<' TypeParameter (',' TypeParameter)* '>')? ;

TypeParameter = id ('extends' Type ('&' Type)*)? ;

Type  =
TypeSpecifier  SquareBracketsList  ;

TypeSpecifier =
 'boolean'
 |  'byte'
 |  'char'
 |  'short'
 |  'int'
 |  'float'
 |  'long'
 |  'double'
 |  'void'
 | CompoundName TypeArguments ;

Modifier =
 'public'
 |  'private'
 |  'protected'
 |  'static'
 |  'final'
 |  'native'
 |  'synchronized'
 |  'abstract'
 |  'threadsafe'
 |  'transient'  ;

CompoundName =
id ('.' id)*;

integerLiteral =
 (  (  [1-9]  [0-9]*  )
 |  ( '0' [0-7]* )
 |  (  '0'  'x'  [0-9a-fA-F]+   )  )
 [l]?  ;

floatLiteral  =
 [0-9]+ '.' ([0-9]+)? exponentPart? floatTypeSuffix?
 |  '.' [0-9]+ exponentPart? floatTypeSuffix?
 |  [0-9]+ floatTypeSuffix ;

exponentPart  =
 'e'  (  '+'  |  '-'  )? [0-9]+  ;

floatTypeSuffix  =
 'f'  |  'd'  ;

char  = '\'' . '\'' ;

string  = [\"] [\\x20-\\x21\\x23-\\x7E]* [\"] ;

id = [a-zA-Z$_][a-zA-Z$_0-9]* ;
doccomment = '/**' (([^/] | [\n]) ([^\*] | [\*] [^/] | [\n])*)? '*/';

# Whitespace and comments (ignored)
Ignore: ws = [ \t\n\r]+ ;
Ignore: comment = '//' [^\n]* '\n' ;
Ignore: blockComment = '/*' (([^\*] | [\n]) ([^\*] | [\*] [^/] | [\n])*)? '*/' ;
