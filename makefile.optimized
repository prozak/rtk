.PHONY: clean help test $(GRAMMAR_TARGETS)

# Enable parallel builds by default
MAKEFLAGS += -j4

# Ensure PATH includes cabal binaries
export PATH := $(HOME)/.local/bin:$(PATH)

# Auto-discover grammar files
GRAMMARS := $(basename $(notdir $(wildcard test-grammars/*.pg)))
GRAMMAR_TARGETS := $(addprefix test-, $(GRAMMARS))

# Optimization flags
HAPPY_FLAGS = --strict --array --ghc
ALEX_FLAGS = --ghc
GHC_DEV_FLAGS = -O0 -j4
GHC_PROD_FLAGS = -O2 -j4

# Build mode (dev or prod)
BUILD_MODE ?= dev

ifeq ($(BUILD_MODE),prod)
    GHC_FLAGS = $(GHC_PROD_FLAGS)
else
    GHC_FLAGS = $(GHC_DEV_FLAGS)
endif

default: help

help:
ifeq ($(OS), Windows_NT)
	@echo Use 'build' target to launch build
	@echo Use 'clean' target to clean binaries
	@echo Use 'test-grammar' target to generate [xy] for test-grammars/grammar.pg
	@echo Use 'test-t1' target to generate [xy] for test-grammars/t1.pg
else
	@echo "Use 'build' target to launch build"
	@echo "Use 'clean' target to clean binaries"
	@echo "Available grammar tests: $(GRAMMAR_TARGETS)"
	@echo "Build modes: BUILD_MODE=dev (default) or BUILD_MODE=prod"
endif

ifeq ($(OS), Windows_NT)
CP=copy
RM=rmdir
RM_OPT=/s /q
BIN_PATH=dist/build/rtk/rtk.exe
else
CP=cp
RM=rm
RM_OPT=-rf
BIN_PATH=dist-newstyle/build/aarch64-osx/ghc-9.12.2/rtk-0.10/x/rtk/build/rtk/rtk
endif

SOURCES=$(wildcard *.hs *.x *.y)
build: $(BIN_PATH)

$(BIN_PATH): $(SOURCES)
	@echo "Building RTK (parallel enabled)..."
	cabal build --ghc-options="$(GHC_FLAGS)"

clean:
	$(RM) $(RM_OPT) test-out
	$(RM) $(RM_OPT) .build-cache
	cabal clean
	cabal configure

# Create build cache directory
.build-cache:
	mkdir -p .build-cache

# Cache grammar checksums to avoid unnecessary rebuilds
.build-cache/%.pg.md5: test-grammars/%.pg .build-cache
	@mkdir -p .build-cache
	@md5sum $< > $@ 2>/dev/null || md5 $< > $@

test: test-out build
	cabal exec ghc -- --make StrQuote_Test.hs -o test-out/strquote-test $(GHC_FLAGS)
	./test-out/strquote-test

test-out:
ifeq ($(OS), Windows_NT)
	mkdir test-out
else
	mkdir -p test-out
endif

# Function to capitalize first letter
capitalize = $(shell echo $(1) | awk '{print toupper(substr($$0,1,1)) tolower(substr($$0,2))}')

# Smart grammar rule with caching
define make-grammar-rule
test-out/$(call capitalize,$(1))Lexer.x test-out/$(call capitalize,$(1))Parser.y : $(BIN_PATH) .build-cache/$(1).pg.md5
	@echo "Checking if $(1).pg changed..."
	@if [ -f test-out/$(call capitalize,$(1))Parser.y ] && \
	   [ -f .build-cache/$(1).pg.md5.last ] && \
	   diff -q .build-cache/$(1).pg.md5 .build-cache/$(1).pg.md5.last > /dev/null 2>&1; then \
		echo "Grammar unchanged, skipping generation"; \
		touch test-out/$(call capitalize,$(1))Lexer.x test-out/$(call capitalize,$(1))Parser.y; \
	else \
		echo "Generating parser for $(1)..."; \
		$(BIN_PATH) test-grammars/$(1).pg test-out && \
		cp .build-cache/$(1).pg.md5 .build-cache/$(1).pg.md5.last; \
	fi
endef

# Generate rules for each grammar
$(foreach grammar,$(GRAMMARS),$(eval $(call make-grammar-rule,$(grammar))))

# Special cases for grammars with different naming patterns
test-out/JavaSimpleLexer.x test-out/JavaSimpleParser.y : $(BIN_PATH) test-grammars/java-simple.pg
	$(BIN_PATH) test-grammars/java-simple.pg test-out

# Optimized Happy compilation with performance flags
%.hs : %.x
	@echo "Compiling lexer with Alex (optimized)..."
	cabal exec alex $< -- $(ALEX_FLAGS) -o $@

%.hs : %.y
	@echo "Compiling parser with Happy (optimized)..."
	cabal exec happy $< -- $(HAPPY_FLAGS) -o $@

# Keep intermediate files
.PRECIOUS: test-out/%.y test-out/%.x test-out/%.hs

# Generic rule to copy main files
test-out/%-main.hs: test-grammars/%-main.hs
	$(CP) test-grammars/$*-main.hs test-out

# Generic test rule - requires main file and test data to be defined
define make-test-rule
test-$(1): build test-out test-out/$(2)Lexer.hs test-out/$(2)Parser.hs test-out/$(1)-main.hs
	@echo "Compiling test executable..."
	cabal exec -- ghc --make -itest-out test-out/$(1)-main.hs -o test-out/$(1)-main $(GHC_FLAGS)
	@echo "Running test..."
	test-out/$(1)-main $(3)
endef

# Define test configurations: grammar-name, lexer-prefix, test-file
$(eval $(call make-test-rule,grammar,Grammar,test-grammars/grammar.pg))
$(eval $(call make-test-rule,java,Java,test-grammars/Test.java))
$(eval $(call make-test-rule,java-simple,JavaSimple,test-grammars/Simple.java))
$(eval $(call make-test-rule,sandbox,Sandbox,test-grammars/test.sandbox))

# Special cases that don't follow the pattern
test-haskell: build test-out test-out/HaskellLexer.hs test-out/HaskellParser.hs
	$(CP) test-grammars/haskell-main.hs test-out
	(cd test-out && ghc --make haskell-main.hs -o haskell-rtk $(GHC_FLAGS))
	test-out/haskell-rtk Normalize.hs

test-t1: test-out build
	$(BIN_PATH) test-grammars/t1.pg test-out

test-p: test-out build test-out/PLexer.hs test-out/PParser.hs
	$(CP) test-grammars/p-main.hs test-out
	(cd test-out && ghc --make p-main.hs -o p-rtk $(GHC_FLAGS))
	test-out/p-rtk expr.p

# Benchmarking target
benchmark: build
	@echo "Running build performance benchmark..."
	@if [ -f benchmark-java-grammar.sh ]; then \
		./benchmark-java-grammar.sh; \
	else \
		echo "Benchmark script not found"; \
	fi

# Show optimization status
optimize-status:
	@echo "Build Optimization Status:"
	@echo "  Parallel builds: $(if $(findstring -j,$(MAKEFLAGS)),ENABLED,DISABLED)"
	@echo "  Build mode: $(BUILD_MODE)"
	@echo "  GHC flags: $(GHC_FLAGS)"
	@echo "  Happy flags: $(HAPPY_FLAGS)"
	@echo "  Build cache: $(if $(wildcard .build-cache),ENABLED,DISABLED)"
