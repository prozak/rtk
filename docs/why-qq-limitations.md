# Why Pattern Matching and Anti-Quotation Don't Work for Java

## Summary

The Java quasi-quoter only supports **construction** mode. Both **pattern matching** and **anti-quotation (splicing)** fail with parse errors.

## Observed Failures

### Pattern Matching Failure

```haskell
case expr of
    [expression| $expression1 + $expression2 |] -> ...
```

**Error:**
```
Parse error [Tk__tok__plus__72,Tk__qq_Expression188 "expression2",Tk__tok_Expression_dummy_349]
```

### Anti-Quotation Failure

```haskell
let expression1 = [expression| a |]
let splicedExpr = [expression| $expression1 + $expression2 |]
```

**Error:**
```
Parse error [Tk__tok__plus__72,Tk__qq_Expression188 "expression2",Tk__tok_Expression_dummy_349]
```

## Root Cause Analysis

The errors indicate that after variable substitution, the generated token stream cannot be parsed by the Java grammar.

### How Quasi-Quotation Works

From `GenQ.hs`:

1. **Pattern Matching**: `replaceAllPatterns` transforms `$variable` → `$Type:variable`
   ```haskell
   replaceAllPatterns1 str =
     let varName = init $ tail match
         ruleVariants = catMaybes $ map (\ prefix -> M.lookup prefix qqShortcuts)
                                        $ reverse $ inits varName
         rule = case ruleVariants of
                  [] -> error $ "Unknown shortcut for " ++ varName
                  (rule : _) -> rule
     in pre ++ ('$' : rule ++ ":") ++ varName ++ ...
   ```

2. **Token Generation**: Creates special tokens like `Tk__qq_Expression188`

3. **Parsing**: Attempts to parse the modified token stream

### The Problem

The Java grammar's parser expects specific token sequences. When quasi-quotation inserts special QQ tokens (`Tk__qq_*`), these don't match the grammar's expected patterns.

**Example**: For `$expression1 + $expression2`:
- After substitution: `$Expression:expression1 + $Expression:expression2`
- Tokens generated: `[..., Tk__tok__plus__72, Tk__qq_Expression188 "expression2", ...]`
- Parser sees unexpected token sequence and fails

## Why It Works for P Language

The P language quasi-quoter works because:
1. Simpler grammar
2. Parser designed to handle QQ tokens
3. Grammar rules specifically accommodate the token patterns generated by QQ

Example from `p-main.hs`:
```haskell
subst id [e|(fold $e1 $e2 (lambda ( $id1 $id2 ) $e3))|] i = ...
```

This works because the P grammar's parser can handle the QQ token patterns.

## Why Java Grammar Fails

The Java grammar is more complex:
1. Complex expression precedence rules
2. Many token types and combinations
3. Parser not designed to handle QQ token patterns
4. The grammar rules don't accommodate `Tk__qq_*` tokens in expression contexts

## Technical Details

### Anti-Rules in Java Grammar

Looking at `java.pg`, there may be anti-quotation rules defined, but the parser doesn't correctly handle them:

```
AntiQuotation Rules = (if defined)
- Would need to handle $variable syntax
- Would need to generate appropriate AST nodes
- Parser would need to recognize QQ tokens
```

The error suggests these aren't properly integrated into the Java grammar's parser.

## What Would Be Needed to Fix This

1. **Modify Java Grammar Parser**: Update parser rules to recognize and handle `Tk__qq_*` tokens
2. **Add Anti-Quotation Support**: Integrate anti-quotation handling into expression/statement parsing
3. **Pattern Matching Support**: Ensure parser can generate pattern matches from QQ syntax
4. **Extensive Testing**: Verify all Java constructs work with QQ

This would be a significant undertaking requiring deep changes to the grammar and parser generation.

## Current Status

✅ **Construction works**: The parser can build AST from Java syntax literals
```haskell
[expression| x + y |]  -- Works fine
```

❌ **Pattern matching doesn't work**: Parser can't handle QQ tokens in patterns
```haskell
case e of [expression| $x + $y |] -> ...  -- Parse error
```

❌ **Anti-quotation doesn't work**: Parser can't handle QQ tokens in expressions
```haskell
let e = [expression| x |] in [expression| $e + y |]  -- Parse error
```

## Conclusion

The Java quasi-quoter is limited to **construction-only** mode. This is still useful for:
- Building AST nodes from Java syntax
- Testing the parser with various Java constructs
- Creating AST templates for code generation

For full quasi-quotation support (pattern matching + anti-quotation), the Java grammar parser would need substantial modifications.

## References

- `GenQ.hs`: Quasi-quoter generator
- `test-grammars/p-main.hs`: Working example in P language
- `test-grammars/java.pg`: Java grammar definition
- Error logs from CI showing parse failures
